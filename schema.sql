-- This script was generated by the Schema Diff utility in pgAdmin 4. 
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated 
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps. 
BEGIN;
CREATE FUNCTION public.atlases_search_trigger()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
  new."searchVector" :=
    setweight(to_tsvector('english', coalesce(new.name, '')),'A') ||
    setweight(to_tsvector('english', coalesce(new.description, '')), 'C');
  return new;
end
$BODY$;

ALTER FUNCTION public.atlases_search_trigger()
    OWNER TO "user";

CREATE FUNCTION public.documents_search_trigger()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
begin
      new."searchVector" :=
        setweight(to_tsvector('english', coalesce(new.title, '')),'A') ||
        setweight(to_tsvector('english', coalesce(array_to_string(new."previousTitles", ' , '),'')),'C') ||
        setweight(to_tsvector('english', coalesce(new.text, '')), 'B');
      return new;
    end
$BODY$;

ALTER FUNCTION public.documents_search_trigger()
    OWNER TO "user";

-- Type: enum_file_operations_state

-- DROP TYPE public.enum_file_operations_state;

CREATE TYPE public.enum_file_operations_state AS ENUM
    ('creating', 'uploading', 'complete', 'error', 'expired');

ALTER TYPE public.enum_file_operations_state
    OWNER TO "user";
-- Type: enum_file_operations_type

-- DROP TYPE public.enum_file_operations_type;

CREATE TYPE public.enum_file_operations_type AS ENUM
    ('import', 'export');

ALTER TYPE public.enum_file_operations_type
    OWNER TO "user";
-- Type: enum_search_queries_source

-- DROP TYPE public.enum_search_queries_source;

CREATE TYPE public.enum_search_queries_source AS ENUM
    ('slack', 'app', 'api');

ALTER TYPE public.enum_search_queries_source
    OWNER TO "user";

CREATE TABLE IF NOT EXISTS public."SequelizeMeta"
(
    name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "SequelizeMeta_pkey" PRIMARY KEY (name)
)

TABLESPACE pg_default;

ALTER TABLE public."SequelizeMeta"
    OWNER to "user";
CREATE TABLE IF NOT EXISTS public."apiKeys"
(
    id uuid NOT NULL,
    name character varying COLLATE pg_catalog."default",
    secret character varying COLLATE pg_catalog."default" NOT NULL,
    "userId" uuid,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    "deletedAt" timestamp with time zone,
    CONSTRAINT "apiKeys_pkey" PRIMARY KEY (id),
    CONSTRAINT "apiKeys_secret_key" UNIQUE (secret)
)

TABLESPACE pg_default;

ALTER TABLE public."apiKeys"
    OWNER to "user";
CREATE INDEX api_keys_secret_deleted_at
    ON public."apiKeys" USING btree
    (secret COLLATE pg_catalog."default" ASC NULLS LAST, "deletedAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX api_keys_user_id_deleted_at
    ON public."apiKeys" USING btree
    ("userId" ASC NULLS LAST, "deletedAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.attachments
(
    id uuid NOT NULL,
    "teamId" uuid NOT NULL,
    "userId" uuid NOT NULL,
    "documentId" uuid,
    key character varying(4096) COLLATE pg_catalog."default" NOT NULL,
    url character varying(4096) COLLATE pg_catalog."default" NOT NULL,
    "contentType" character varying(255) COLLATE pg_catalog."default" NOT NULL,
    size bigint NOT NULL,
    acl character varying(255) COLLATE pg_catalog."default" NOT NULL,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    CONSTRAINT attachments_pkey PRIMARY KEY (id),
    CONSTRAINT "attachments_teamId_fkey" FOREIGN KEY ("teamId")
        REFERENCES public.teams (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "attachments_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.attachments
    OWNER to "user";
CREATE INDEX attachments_document_id
    ON public.attachments USING btree
    ("documentId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.authentication_providers
(
    id uuid NOT NULL,
    name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    "providerId" character varying(255) COLLATE pg_catalog."default" NOT NULL,
    enabled boolean NOT NULL DEFAULT true,
    "teamId" uuid NOT NULL,
    "createdAt" timestamp with time zone NOT NULL,
    CONSTRAINT authentication_providers_pkey PRIMARY KEY (id),
    CONSTRAINT "authentication_providers_providerId_key" UNIQUE ("providerId"),
    CONSTRAINT "authentication_providers_teamId_fkey" FOREIGN KEY ("teamId")
        REFERENCES public.teams (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.authentication_providers
    OWNER to "user";
CREATE INDEX authentication_providers_provider_id
    ON public.authentication_providers USING btree
    ("providerId" COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.authentications
(
    id uuid NOT NULL,
    "userId" uuid,
    "teamId" uuid,
    service character varying(255) COLLATE pg_catalog."default" NOT NULL,
    token bytea,
    scopes character varying(255)[] COLLATE pg_catalog."default",
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    CONSTRAINT authentications_pkey PRIMARY KEY (id),
    CONSTRAINT "authentications_teamId_fkey" FOREIGN KEY ("teamId")
        REFERENCES public.teams (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "authentications_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.authentications
    OWNER to "user";
CREATE TABLE IF NOT EXISTS public.backlinks
(
    id uuid NOT NULL,
    "userId" uuid NOT NULL,
    "documentId" uuid NOT NULL,
    "reverseDocumentId" uuid NOT NULL,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    CONSTRAINT backlinks_pkey PRIMARY KEY (id),
    CONSTRAINT "backlinks_documentId_fkey" FOREIGN KEY ("documentId")
        REFERENCES public.documents (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT "backlinks_reverseDocumentId_fkey" FOREIGN KEY ("reverseDocumentId")
        REFERENCES public.documents (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT "backlinks_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.backlinks
    OWNER to "user";
CREATE INDEX backlinks_document_id
    ON public.backlinks USING btree
    ("documentId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX backlinks_reverse_document_id
    ON public.backlinks USING btree
    ("reverseDocumentId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.collection_groups
(
    "collectionId" uuid NOT NULL,
    "groupId" uuid NOT NULL,
    "createdById" uuid NOT NULL,
    permission character varying(255) COLLATE pg_catalog."default" NOT NULL,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    "deletedAt" timestamp with time zone,
    CONSTRAINT "collection_groups_collectionId_fkey" FOREIGN KEY ("collectionId")
        REFERENCES public.collections (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "collection_groups_createdById_fkey" FOREIGN KEY ("createdById")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "collection_groups_groupId_fkey" FOREIGN KEY ("groupId")
        REFERENCES public.groups (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.collection_groups
    OWNER to "user";
CREATE INDEX collection_groups_collection_id_group_id
    ON public.collection_groups USING btree
    ("collectionId" ASC NULLS LAST, "groupId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX collection_groups_deleted_at
    ON public.collection_groups USING btree
    ("deletedAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX collection_groups_group_id
    ON public.collection_groups USING btree
    ("groupId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.collection_users
(
    "collectionId" uuid NOT NULL,
    "userId" uuid NOT NULL,
    permission character varying(255) COLLATE pg_catalog."default" NOT NULL DEFAULT 'read_write'::character varying,
    "createdById" uuid NOT NULL,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    CONSTRAINT "collection_users_collectionId_fkey" FOREIGN KEY ("collectionId")
        REFERENCES public.collections (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "collection_users_createdById_fkey" FOREIGN KEY ("createdById")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "collection_users_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.collection_users
    OWNER to "user";
CREATE INDEX collection_users_collection_id_user_id
    ON public.collection_users USING btree
    ("collectionId" ASC NULLS LAST, "userId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.collections
(
    id uuid NOT NULL,
    name character varying COLLATE pg_catalog."default",
    description character varying COLLATE pg_catalog."default",
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    "teamId" uuid NOT NULL,
    "searchVector" tsvector,
    "createdById" uuid,
    "deletedAt" timestamp with time zone,
    "urlId" character varying(255) COLLATE pg_catalog."default",
    "documentStructure" jsonb,
    color text COLLATE pg_catalog."default",
    "maintainerApprovalRequired" boolean NOT NULL DEFAULT false,
    icon text COLLATE pg_catalog."default",
    sort jsonb,
    sharing boolean NOT NULL DEFAULT true,
    index text COLLATE pg_catalog."default",
    permission character varying(255) COLLATE pg_catalog."default" DEFAULT NULL::character varying,
    CONSTRAINT atlases_pkey PRIMARY KEY (id),
    CONSTRAINT "atlases_urlId_key" UNIQUE ("urlId")
)

TABLESPACE pg_default;

ALTER TABLE public.collections
    OWNER to "user";
CREATE INDEX atlases_id_deleted_at
    ON public.collections USING btree
    (id ASC NULLS LAST, "deletedAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX atlases_id_team_id_deleted_at
    ON public.collections USING btree
    (id ASC NULLS LAST, "teamId" ASC NULLS LAST, "deletedAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX atlases_tsv_idx
    ON public.collections USING gin
    ("searchVector")
    TABLESPACE pg_default;

CREATE TRIGGER atlases_tsvectorupdate
    BEFORE INSERT OR UPDATE 
    ON public.collections
    FOR EACH ROW
    EXECUTE FUNCTION public.atlases_search_trigger();
CREATE TABLE IF NOT EXISTS public.documents
(
    id uuid NOT NULL,
    "urlId" character varying COLLATE pg_catalog."default" NOT NULL,
    title character varying COLLATE pg_catalog."default" NOT NULL,
    text text COLLATE pg_catalog."default",
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    "userId" uuid,
    "collectionId" uuid,
    "teamId" uuid,
    "parentDocumentId" uuid,
    "lastModifiedById" uuid NOT NULL,
    "revisionCount" integer DEFAULT 0,
    "searchVector" tsvector,
    "deletedAt" timestamp with time zone,
    "createdById" uuid,
    "collaboratorIds" uuid[],
    emoji character varying(255) COLLATE pg_catalog."default",
    "publishedAt" timestamp with time zone,
    "pinnedById" uuid,
    "archivedAt" timestamp with time zone,
    "isWelcome" boolean NOT NULL DEFAULT false,
    "editorVersion" character varying(255) COLLATE pg_catalog."default",
    version smallint,
    template boolean NOT NULL DEFAULT false,
    "templateId" uuid,
    "previousTitles" character varying(255)[] COLLATE pg_catalog."default",
    CONSTRAINT documents_pkey PRIMARY KEY (id),
    CONSTRAINT "documents_urlId_key" UNIQUE ("urlId"),
    CONSTRAINT "documents_atlasId_fkey" FOREIGN KEY ("collectionId")
        REFERENCES public.collections (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT "documents_createdById_fkey" FOREIGN KEY ("createdById")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "documents_lastModifiedById_fkey" FOREIGN KEY ("lastModifiedById")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "documents_parentDocumentId_fkey" FOREIGN KEY ("parentDocumentId")
        REFERENCES public.documents (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT "documents_teamId_fkey" FOREIGN KEY ("teamId")
        REFERENCES public.teams (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT "documents_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.documents
    OWNER to "user";
CREATE INDEX documents_archived_at
    ON public.documents USING btree
    ("archivedAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX documents_id_atlas_id_deleted_at
    ON public.documents USING btree
    (id ASC NULLS LAST, "collectionId" ASC NULLS LAST, "deletedAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX documents_id_atlas_id_published_at
    ON public.documents USING btree
    (id ASC NULLS LAST, "collectionId" ASC NULLS LAST, "publishedAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX documents_id_team_id_deleted_at
    ON public.documents USING btree
    (id ASC NULLS LAST, "teamId" ASC NULLS LAST, "deletedAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX documents_parent_document_id_atlas_id_deleted_at
    ON public.documents USING btree
    ("parentDocumentId" ASC NULLS LAST, "collectionId" ASC NULLS LAST, "deletedAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX documents_tsv_idx
    ON public.documents USING gin
    ("searchVector")
    TABLESPACE pg_default;
CREATE INDEX documents_updated_at
    ON public.documents USING btree
    ("updatedAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX documents_url_id_deleted_at
    ON public.documents USING btree
    ("urlId" COLLATE pg_catalog."default" ASC NULLS LAST, "deletedAt" ASC NULLS LAST)
    TABLESPACE pg_default;

CREATE TRIGGER documents_tsvectorupdate
    BEFORE INSERT OR UPDATE 
    ON public.documents
    FOR EACH ROW
    EXECUTE FUNCTION public.documents_search_trigger();
CREATE TABLE IF NOT EXISTS public.events
(
    id uuid NOT NULL,
    name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    data jsonb,
    "userId" uuid,
    "collectionId" uuid,
    "teamId" uuid,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    "documentId" uuid,
    "actorId" uuid,
    "modelId" uuid,
    ip character varying(255) COLLATE pg_catalog."default",
    CONSTRAINT events_pkey PRIMARY KEY (id),
    CONSTRAINT "events_actorId_fkey" FOREIGN KEY ("actorId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "events_collectionId_fkey" FOREIGN KEY ("collectionId")
        REFERENCES public.collections (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "events_teamId_fkey" FOREIGN KEY ("teamId")
        REFERENCES public.teams (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "events_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.events
    OWNER to "user";
CREATE INDEX events_actor_id
    ON public.events USING btree
    ("actorId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX events_document_id
    ON public.events USING btree
    ("documentId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX events_name
    ON public.events USING btree
    (name COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX events_team_id_collection_id
    ON public.events USING btree
    ("teamId" ASC NULLS LAST, "collectionId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.file_operations
(
    id uuid NOT NULL,
    state enum_file_operations_state NOT NULL,
    type enum_file_operations_type NOT NULL,
    key character varying(255) COLLATE pg_catalog."default",
    url character varying(255) COLLATE pg_catalog."default",
    size bigint NOT NULL,
    "userId" uuid NOT NULL,
    "collectionId" uuid,
    "teamId" uuid NOT NULL,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    CONSTRAINT file_operations_pkey PRIMARY KEY (id),
    CONSTRAINT "file_operations_collectionId_fkey" FOREIGN KEY ("collectionId")
        REFERENCES public.collections (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "file_operations_teamId_fkey" FOREIGN KEY ("teamId")
        REFERENCES public.teams (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "file_operations_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.file_operations
    OWNER to "user";
CREATE INDEX file_operations_type_state
    ON public.file_operations USING btree
    (type ASC NULLS LAST, state ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.group_users
(
    "userId" uuid NOT NULL,
    "groupId" uuid NOT NULL,
    "createdById" uuid NOT NULL,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    "deletedAt" timestamp with time zone,
    CONSTRAINT "group_users_createdById_fkey" FOREIGN KEY ("createdById")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "group_users_groupId_fkey" FOREIGN KEY ("groupId")
        REFERENCES public.groups (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "group_users_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.group_users
    OWNER to "user";
CREATE INDEX group_users_deleted_at
    ON public.group_users USING btree
    ("deletedAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX group_users_group_id_user_id
    ON public.group_users USING btree
    ("groupId" ASC NULLS LAST, "userId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX group_users_user_id
    ON public.group_users USING btree
    ("userId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.groups
(
    id uuid NOT NULL,
    name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    "teamId" uuid NOT NULL,
    "createdById" uuid NOT NULL,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    "deletedAt" timestamp with time zone,
    CONSTRAINT groups_pkey PRIMARY KEY (id),
    CONSTRAINT "groups_createdById_fkey" FOREIGN KEY ("createdById")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "groups_teamId_fkey" FOREIGN KEY ("teamId")
        REFERENCES public.teams (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.groups
    OWNER to "user";
CREATE INDEX groups_deleted_at
    ON public.groups USING btree
    ("deletedAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX groups_team_id
    ON public.groups USING btree
    ("teamId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.integrations
(
    id uuid NOT NULL,
    type character varying(255) COLLATE pg_catalog."default",
    "userId" uuid,
    "teamId" uuid,
    service character varying(255) COLLATE pg_catalog."default" NOT NULL,
    "collectionId" uuid,
    "authenticationId" uuid NOT NULL,
    events character varying(255)[] COLLATE pg_catalog."default",
    settings jsonb,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    CONSTRAINT integrations_pkey PRIMARY KEY (id),
    CONSTRAINT "integrations_authenticationId_fkey" FOREIGN KEY ("authenticationId")
        REFERENCES public.authentications (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "integrations_collectionId_fkey" FOREIGN KEY ("collectionId")
        REFERENCES public.collections (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "integrations_teamId_fkey" FOREIGN KEY ("teamId")
        REFERENCES public.teams (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "integrations_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.integrations
    OWNER to "user";
CREATE TABLE IF NOT EXISTS public.notification_settings
(
    id uuid NOT NULL,
    "userId" uuid NOT NULL,
    "teamId" uuid NOT NULL,
    event character varying(255) COLLATE pg_catalog."default",
    "createdAt" timestamp with time zone NOT NULL,
    CONSTRAINT notification_settings_pkey PRIMARY KEY (id),
    CONSTRAINT "notification_settings_teamId_fkey" FOREIGN KEY ("teamId")
        REFERENCES public.teams (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "notification_settings_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.notification_settings
    OWNER to "user";
CREATE INDEX notification_settings_event
    ON public.notification_settings USING btree
    (event COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX notification_settings_team_id_user_id
    ON public.notification_settings USING btree
    ("teamId" ASC NULLS LAST, "userId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.notifications
(
    id uuid NOT NULL,
    "actorId" uuid NOT NULL,
    "userId" uuid NOT NULL,
    event character varying(255) COLLATE pg_catalog."default",
    email boolean,
    "createdAt" timestamp with time zone NOT NULL,
    CONSTRAINT notifications_pkey PRIMARY KEY (id),
    CONSTRAINT "notifications_actorId_fkey" FOREIGN KEY ("actorId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "notifications_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.notifications
    OWNER to "user";
CREATE TABLE IF NOT EXISTS public.revisions
(
    id uuid NOT NULL,
    title character varying COLLATE pg_catalog."default" NOT NULL,
    text text COLLATE pg_catalog."default",
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    "userId" uuid NOT NULL,
    "documentId" uuid NOT NULL,
    "editorVersion" character varying(255) COLLATE pg_catalog."default",
    version smallint,
    CONSTRAINT revisions_pkey PRIMARY KEY (id),
    CONSTRAINT "revisions_documentId_fkey" FOREIGN KEY ("documentId")
        REFERENCES public.documents (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT "revisions_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.revisions
    OWNER to "user";
CREATE INDEX revisions_document_id
    ON public.revisions USING btree
    ("documentId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.search_queries
(
    id uuid NOT NULL,
    "userId" uuid,
    "teamId" uuid,
    source enum_search_queries_source NOT NULL,
    query character varying(255) COLLATE pg_catalog."default" NOT NULL,
    results integer NOT NULL,
    "createdAt" timestamp with time zone NOT NULL,
    CONSTRAINT search_queries_pkey PRIMARY KEY (id),
    CONSTRAINT "search_queries_teamId_fkey" FOREIGN KEY ("teamId")
        REFERENCES public.teams (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "search_queries_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.search_queries
    OWNER to "user";
CREATE INDEX search_queries_created_at
    ON public.search_queries USING btree
    ("createdAt" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX search_queries_team_id
    ON public.search_queries USING btree
    ("teamId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX search_queries_user_id
    ON public.search_queries USING btree
    ("userId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.shares
(
    id uuid NOT NULL,
    "userId" uuid NOT NULL,
    "teamId" uuid NOT NULL,
    "documentId" uuid NOT NULL,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    "revokedAt" timestamp with time zone,
    "revokedById" uuid,
    published boolean NOT NULL DEFAULT false,
    "lastAccessedAt" timestamp with time zone,
    "includeChildDocuments" boolean NOT NULL DEFAULT false,
    CONSTRAINT shares_pkey PRIMARY KEY (id),
    CONSTRAINT "shares_documentId_fkey" FOREIGN KEY ("documentId")
        REFERENCES public.documents (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT "shares_revokedById_fkey" FOREIGN KEY ("revokedById")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "shares_teamId_fkey" FOREIGN KEY ("teamId")
        REFERENCES public.teams (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "shares_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.shares
    OWNER to "user";
CREATE TABLE IF NOT EXISTS public.stars
(
    id uuid NOT NULL,
    "documentId" uuid NOT NULL,
    "userId" uuid NOT NULL,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    CONSTRAINT stars_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE public.stars
    OWNER to "user";
CREATE INDEX stars_document_id_user_id
    ON public.stars USING btree
    ("documentId" ASC NULLS LAST, "userId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.teams
(
    id uuid NOT NULL,
    name character varying COLLATE pg_catalog."default",
    "slackId" character varying(255) COLLATE pg_catalog."default",
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    "googleId" character varying(255) COLLATE pg_catalog."default",
    "avatarUrl" character varying(255) COLLATE pg_catalog."default",
    "deletedAt" timestamp with time zone,
    sharing boolean NOT NULL DEFAULT true,
    subdomain character varying(255) COLLATE pg_catalog."default",
    "documentEmbeds" boolean NOT NULL DEFAULT true,
    "guestSignin" boolean NOT NULL DEFAULT false,
    domain character varying(255) COLLATE pg_catalog."default",
    "signupQueryParams" jsonb,
    CONSTRAINT teams_pkey PRIMARY KEY (id),
    CONSTRAINT teams_domain_key UNIQUE (domain),
    CONSTRAINT "teams_googleId_key" UNIQUE ("googleId"),
    CONSTRAINT "teams_slackId_key" UNIQUE ("slackId"),
    CONSTRAINT teams_subdomain_key UNIQUE (subdomain)
)

TABLESPACE pg_default;

ALTER TABLE public.teams
    OWNER to "user";
CREATE INDEX teams_subdomain
    ON public.teams USING btree
    (subdomain COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.user_authentications
(
    id uuid NOT NULL,
    "userId" uuid NOT NULL,
    "authenticationProviderId" uuid NOT NULL,
    "accessToken" bytea,
    "refreshToken" bytea,
    scopes character varying(255)[] COLLATE pg_catalog."default",
    "providerId" character varying(255) COLLATE pg_catalog."default" NOT NULL,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    CONSTRAINT user_authentications_pkey PRIMARY KEY (id),
    CONSTRAINT "user_authentications_providerId_key" UNIQUE ("providerId"),
    CONSTRAINT "user_authentications_authenticationProviderId_fkey" FOREIGN KEY ("authenticationProviderId")
        REFERENCES public.authentication_providers (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT "user_authentications_userId_fkey" FOREIGN KEY ("userId")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.user_authentications
    OWNER to "user";
CREATE INDEX user_authentications_provider_id
    ON public.user_authentications USING btree
    ("providerId" COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.users
(
    id uuid NOT NULL,
    email character varying(255) COLLATE pg_catalog."default" DEFAULT NULL::character varying,
    username character varying(255) COLLATE pg_catalog."default",
    name character varying COLLATE pg_catalog."default" NOT NULL,
    "isAdmin" boolean DEFAULT false,
    "serviceId" character varying(255) COLLATE pg_catalog."default",
    "jwtSecret" bytea,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    "teamId" uuid,
    "avatarUrl" text COLLATE pg_catalog."default",
    "suspendedById" uuid,
    "suspendedAt" timestamp with time zone,
    service character varying(255) COLLATE pg_catalog."default" DEFAULT 'slack'::character varying,
    "lastActiveAt" timestamp with time zone,
    "lastActiveIp" character varying(255) COLLATE pg_catalog."default",
    "lastSignedInAt" timestamp with time zone,
    "lastSignedInIp" character varying(255) COLLATE pg_catalog."default",
    "deletedAt" timestamp with time zone,
    "lastSigninEmailSentAt" timestamp with time zone,
    language character varying(255) COLLATE pg_catalog."default" DEFAULT 'en_US'::character varying,
    "isViewer" boolean NOT NULL DEFAULT false,
    CONSTRAINT users_pkey PRIMARY KEY (id),
    CONSTRAINT "users_slackId_key" UNIQUE ("serviceId"),
    CONSTRAINT "users_slackId_key1" UNIQUE ("serviceId"),
    CONSTRAINT "users_suspendedById_fkey" FOREIGN KEY ("suspendedById")
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE public.users
    OWNER to "user";
CREATE INDEX users_team_id
    ON public.users USING btree
    ("teamId" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE TABLE IF NOT EXISTS public.views
(
    id uuid NOT NULL,
    "documentId" uuid NOT NULL,
    "userId" uuid NOT NULL,
    count integer NOT NULL DEFAULT 1,
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    "lastEditingAt" timestamp with time zone,
    CONSTRAINT views_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE public.views
    OWNER to "user";
CREATE INDEX views_document_id_user_id
    ON public.views USING btree
    ("documentId" ASC NULLS LAST, "userId" ASC NULLS LAST)
    TABLESPACE pg_default;

END;